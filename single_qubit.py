from itertools import product
from tqdm import tqdm
import pennylane as qml
import numpy as np
from pennylane.ops.qubit.special_unitary import pauli_basis_strings, pauli_basis_matrices
from pennylane.operation import Operation
import jax

jax.config.update("jax_enable_x64", True)
jnp = jax.numpy


def get_random_observable(N: int):
    """TODO"""
    basis = pauli_basis_matrices(N)
    c = np.random.randn(4**N - 1)
    return qml.math.tensordot(c, basis, axes=1)


class MyExp(Operation):
    """TODO"""
    num_params = 1
    num_wires = 1

    def __init__(self, t, wires, generator=None, do_queue=True, id=None):
        self._generator = generator
        self.num_wires = len(wires)
        super().__init__(t, wires=wires, do_queue=do_queue, id=id)
        self.hyperparameters["generator"] = generator

    def generator(self):
        """
        MyExp(t) = exp(t\Omega) = exp(i t (-i \Omega))
        """
        return -1j * self._generator

    @property
    def parameter_frequencies(self):
        eigvals = qml.math.linalg.eigvalsh(qml.math.to_numpy(qml.math.detach(self.generator())))
        fs = (qml.gradients.eigvals_to_frequencies(tuple(eigvals)),)
        return fs

    def adjoint(self):
        return MyExp(-self.data[0], wires=self.wires, generator=self._generator)

    @staticmethod
    def compute_matrix(t, generator):
        return qml.math.expm(t * generator)


def circuit(a, b, observable):
    """Quantum circuit with a single-qubit SpecialUnitary and an expectation value
    measurement. The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate.

    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        observable (qml.Observable): Observable to measure the expectation value of

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.0])
    qml.SpecialUnitary(theta, [0])
    return qml.expval(observable)


def circuit_with_opg(a, b, t, observable):
    """Quantum circuit with a single-qubit SpecialUnitary, as well as a one-parameter group
    corresponding to the first parameter of said unitary, and an expectation value
    measurement. The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate.

    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        observable (qml.Observable): Observable to measure the expectation value of
        t (float): Parameter for the one-parameter group inserted before the SpecialUnitary gate.
            The one-parameter group is hard-coded to be generated by the effective generator
            corresponding to the first parameter of the SpecialUnitary gate.

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.0])
    # Obtain the effective generator for the first parameter of the SpecialUnitary. For this,
    # we stop the queuing of PennyLane while creating the operation, and apply it manually later on
    with qml.queuing.QueuingManager.stop_recording():
        op = qml.SpecialUnitary(theta, [0])
    Omega = op.get_one_parameter_generators("jax")[0]

    MyExp(t, [0], generator=Omega)
    qml.apply(op)
    return qml.expval(observable)

def circuit_for_spsr(a, b, s, sign, observable):
    """Quantum circuit with a single-qubit SpecialUnitary interrupted by a rotation about
    PauliX by an angle of $\pm\pi/4$ and an expectation value measurement.
    The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate, as well as the splitting time.

    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        s (float): Splitting time for the SpecialUnitary
        sign (int): Sign in front of the inserted PauliX rotation
        observable (qml.Observable): Observable to measure the expectation value of

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.0])
    qml.SpecialUnitary((1-s) * theta, [0])
    qml.RX(-sign * jnp.pi/2, [0])
    qml.SpecialUnitary(s * theta, [0])
    return qml.expval(observable)


def finite_diff_first(fun, dx=5e-5, argnums=0):
    """Compute the second-order finite difference approximation of the first order derivative."""
    """TODO"""
    if isinstance(argnums, int):
        argnums = [argnums]

    def wrapped(*args, **kwargs):
        grad = []
        for i in argnums:
            new_args = args[:i] + (args[i] + dx / 2,) + args[i + 1 :]
            fun_plus = fun(*new_args, **kwargs)
            new_args = args[:i] + (args[i] - dx / 2,) + args[i + 1 :]
            fun_minus = fun(*new_args, **kwargs)
            grad.append((fun_plus - fun_minus) / dx)
        return jnp.array(grad)

    return wrapped

def spsr_evaluation(fun, num_samples):
    """Evaluate the stochastic parameter-shift rule of a function by
    evaluating an adequately adapted function for a given number of
    samples and with positive and negative signs, returning their 
    average difference.
    TODO
    """

    def wrapped(*args, **kwargs):
        split_times = np.random.uniform(size=num_samples)
        diffs = [
            fun(*args, s, 1, **kwargs) - fun(*args, s, -1, **kwargs)
            for s in split_times
        ]
        return jnp.array(diffs)

    return wrapped


def setup_grad_fn(method=None, observable=None, shots=None, **diff_kwargs):

    nqubits = 1
    dev_shots = shots if shots is None else [1] * shots
    dev = qml.device("default.qubit", wires=nqubits, shots=dev_shots)
    if method == "autodiff":
        if shots is not None:
            raise ValueError("With autodiff we require shots=None")
        qnode = qml.QNode(circuit, dev, interface="jax")
        grad_fn = jax.jit(jax.grad(qnode, argnums=0), static_argnums=2)
        qnode = jax.jit(qnode, static_argnums=2)
    elif method == r"$\mathrm{SU}(N)$ parameter-shift":
        qnode = qml.QNode(circuit_with_opg, dev, interface="jax", diff_method="parameter-shift")
        if shots is None:
            grad_fn = jax.grad(qnode, argnums=2)
        else:
            grad_fn = jax.jacobian(qnode, argnums=2)
    elif method == "Finite difference":
        delta = diff_kwargs.get("delta")
        qnode = qml.QNode(circuit, dev, interface="jax", diff_method=None)
        grad_fn = finite_diff_first(qnode, dx=delta, argnums=0)
    elif method == "Stochastic parameter-shift":
        num_samples = diff_kwargs.get("num_samples")
        qnode = qml.QNode(circuit_for_spsr, dev, interface="jax", diff_method=None)
        grad_fn = spsr_evaluation(qnode, num_samples)

    return grad_fn


def evaluate_on_grid(fun, a_grid, b_grid, *other_args, sampled=False, **kwargs):
    """Evaluate a function on a grid of values for two parameters, a and b. Optionally
    split the evaluation into mean and standard deviation.

    Args:
    TODO

    """
    shape = (len(a_grid), len(b_grid))
    if sampled:
        result_mean = np.zeros(shape)
        result_std = np.zeros(shape)
        for tuples in tqdm(product(enumerate(a_grid), enumerate(b_grid)), total=np.prod(shape)):
            ids, args = zip(*tuples)
            samples = fun(*args, *other_args, **kwargs)
            result_mean[ids] = jnp.mean(samples)
            result_std[ids] = jnp.std(samples)
        return result_mean, result_std
    else:
        result = np.zeros(shape)
        for tuples in product(enumerate(a_grid), enumerate(b_grid)):
            ids, args = zip(*tuples)
            result[ids] = fun(*args, *other_args, **kwargs)
        return result
