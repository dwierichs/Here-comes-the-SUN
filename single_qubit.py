from itertools import product
from tqdm import tqdm
import pennylane as qml
import numpy as np
from pennylane.ops.qubit.special_unitary import pauli_basis_strings, pauli_basis_matrices
from pennylane.operation import Operation
import jax

jax.config.update("jax_enable_x64", True)
jax.config.update("jax_platform_name", "cpu")
jnp = jax.numpy


def get_random_observable(N: int):
    """Create a random Hermitian matrix by sampling random normal variables and using
    them as coefficients in the Pauli basis.

    Args:
        N (int): Number of qubits

    Returns:
        ndarray: Hermitian matrix of shape ``(2**N, 2**N)``
    """
    basis = pauli_basis_matrices(N)
    c = np.random.randn(4**N - 1)
    return qml.math.tensordot(c, basis, axes=1)


class OneParameterGroup(Operation):
    r"""Custom operation corresponding to the one-parameter group of a given generator.
    Has particular properties compared to ``qml.Exp`` that enable parameter-shift
    derivatives.

    Args:
        t (float): evolution time / parameter of the exponential
        wires (qml.wires.Wires): wires to act on
        generator (tensor_like): generator of the group, given as skew-Hermitian matrix
        do_queue (bool): indicates whether the operator should be
            recorded when created in a tape context
        id (str): custom label given to an operator instance,
            can be useful for some applications where the instance has to be identified

    The one-parameter group is defined as

    .. math::

        U(t, \Omega) = \exp(t\Omega)

    """
    num_params = 1 # The time parameter is the only trainable parameter

    def __init__(self, t, wires, generator=None, do_queue=True, id=None):
        self._generator = generator
        self.num_wires = len(wires)
        super().__init__(t, wires=wires, do_queue=do_queue, id=id)
        self.hyperparameters["generator"] = generator

    def generator(self):
        r"""The generator is supposed to generate the unitary time evolution, so that
        it differs from the generator of the one-parameter group by an imaginary unit:

        .. math::

            \operatorname{OneParameterGroup}(t) = \exp(t\Omega) = \exp(i t (-i \Omega))
        """
        return -1j * self._generator

    @property
    def parameter_frequencies(self):
        """The parameter frequencies of the operation when used within an expectation
        value-based cost function. They can be computed directly from the generator
        of the operation, and hence from the generator of the one-parameter group.

        .. seealso:: :func:`OneParameterGroup.generator`

        """
        eigvals = qml.math.linalg.eigvalsh(qml.math.to_numpy(qml.math.detach(self.generator())))
        return (qml.gradients.eigvals_to_frequencies(tuple(eigvals)),)

    def adjoint(self):
        """The adjoint of a one-parameter group is given by inverting the parameter sign."""
        return OneParameterGroup(-self.data[0], wires=self.wires, generator=self._generator)

    @staticmethod
    def compute_matrix(t, generator):
        """Compute the matrix of the one-parameter group by calculating the
        matrix exponential that defines it."""
        return qml.math.expm(t * generator)


def circuit(a, b, observable):
    """Quantum circuit with a single-qubit SpecialUnitary and an expectation value
    measurement. The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate.

    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        observable (qml.Observable): Observable to measure the expectation value of

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.0])
    qml.SpecialUnitary(theta, [0])
    return qml.expval(observable)

def circuit_with_opg(a, b, t, observable):
    """Quantum circuit with a single-qubit SpecialUnitary, as well as a one-parameter group
    corresponding to the first parameter of said unitary, and an expectation value
    measurement. The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate.

    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        t (float): Parameter for the one-parameter group inserted before the SpecialUnitary gate.
            The one-parameter group is hard-coded to be generated by the effective generator
            corresponding to the first parameter of the SpecialUnitary gate.
        observable (qml.Observable): Observable to measure the expectation value of

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.0])
    # Obtain the effective generator for the first parameter of the SpecialUnitary. For this,
    # we stop the queuing of PennyLane while creating the operation, and apply it manually later on
    with qml.queuing.QueuingManager.stop_recording():
        op = qml.SpecialUnitary(theta, [0])
    Omega = op.get_one_parameter_generators("jax")[0]

    OneParameterGroup(t, [0], generator=Omega)
    qml.apply(op)
    return qml.expval(observable)

def circuit_for_spsr(a, b, s, sign, observable):
    """Quantum circuit with a single-qubit SpecialUnitary interrupted by a rotation about
    PauliX by an angle of $\pm\pi/4$ and an expectation value measurement.
    The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate, as well as the splitting time.

    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        s (float): Splitting time for the SpecialUnitary
        sign (int): Sign in front of the inserted PauliX rotation
        observable (qml.Observable): Observable to measure the expectation value of

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.0])
    qml.SpecialUnitary((1-s) * theta, [0])
    qml.RX(-sign * jnp.pi/2, [0])
    qml.SpecialUnitary(s * theta, [0])
    return qml.expval(observable)


def finite_diff_first(fun, delta=5e-5, argnums=0):
    r"""Compute the second-order finite difference approximation of the
    first-order derivative of a function.

    Args:
        fun (callable): function to differentiate
        delta (float): (doubled) shift value to use in the differentiation recipe.
        argnums (int or list[int]): arguments to compute the derivative for

    Returns:
        callable: function that takes the same arguments as ``fun`` but returns
        the first-order derivative in form of a second order approximation.

    The used differentiation recipe is

    .. math::

        \partial_{\text{FD},x} f(x) = [f(x+\delta/2) - f(x-\delta/2)] / \delta

    so that ``delta`` determines the distance between the two evaluated points, or
    ``\delta/2`` determines the shift size.
    """
    if isinstance(argnums, int):
        argnums = [argnums]

    def wrapped(*args, **kwargs):
        grad = []
        for i in argnums:
            new_args = args[:i] + (args[i] + delta / 2,) + args[i + 1 :]
            fun_plus = fun(*new_args, **kwargs)
            new_args = args[:i] + (args[i] - delta / 2,) + args[i + 1 :]
            fun_minus = fun(*new_args, **kwargs)
            grad.append((fun_plus - fun_minus) / delta)
        return jnp.array(grad)

    return wrapped

def spsr_evaluation(fun, num_samples):
    r"""Evaluate the stochastic parameter-shift rule of a function by sampling
    splitting times and averaging the corresponding parameter-shift derivatives.
    Requires the passed function to have a specific signature.

    Args:
        fun (callable): function to differentiate with specific signature
            ``fun(*args, split_time, sign, **kwargs)``
        num_samples (int): Number of Monte Carlo samples to use
    
    Returns:
        callable: function with the signature ``f(*args, **kwargs)`` where the arguments
        correspond to those without ``split_time`` and ``sign`` in the original function.

    Compute the stochastic parameter-shift rule derivative by sampling splitting times
    ``s`` and computing the parameter-shift rule for each splitting time, averaging
    all obtained derivatives in the end. See 
    `Banchi & Crooks (2021) <https://quantum-journal.org/papers/q-2021-01-25-386/>`__ for
    details.
    """

    def wrapped(*args, **kwargs):
        split_times = np.random.uniform(size=num_samples)
        diffs = [
            fun(*args, s, 1, **kwargs) - fun(*args, s, -1, **kwargs)
            for s in split_times
        ]
        return jnp.array(diffs)

    return wrapped


def setup_grad_fn(method=None, observable=None, shots=None, **diff_kwargs):
    """Create the gradient function for the single-qubit numerical experiments
    in the paper, Section III, using the indicated method.
    
    Args:
        method (str): differentiation method to use. See the code for the eligible options
        observable (tensor_like): matrix of the observable to be measured
        shots (int or None): number of shots to use. If ``None``, compute analytical results
        diff_kwargs (dict): optional arguments for the finite difference and stochast
            parameter-shift rule derivatives

    Returns:
        callable: Function that computes the gradient with respect to the first parameter
        of the single-qubit toy example in the paper, Section III.
    """
    nqubits = 1
    dev_shots = shots if shots is None else [1] * shots
    dev = qml.device("default.qubit", wires=nqubits, shots=dev_shots)
    if method == "autodiff":
        if shots is not None:
            raise ValueError("With autodiff we require shots=None")
        qnode = qml.QNode(circuit, dev, interface="jax")
        grad_fn = jax.jit(jax.grad(qnode, argnums=0), static_argnums=2)
        qnode = jax.jit(qnode, static_argnums=2)
    elif method == r"$\mathrm{SU}(N)$ parameter-shift":
        qnode = qml.QNode(circuit_with_opg, dev, interface="jax", diff_method="parameter-shift")
        if shots is None:
            grad_fn = jax.grad(qnode, argnums=2)
        else:
            grad_fn = jax.jacobian(qnode, argnums=2)
    elif method == "Finite difference":
        delta = diff_kwargs.get("delta")
        qnode = qml.QNode(circuit, dev, interface="jax", diff_method=None)
        grad_fn = finite_diff_first(qnode, delta=delta, argnums=0)
    elif method == "Stochastic parameter-shift":
        num_samples = diff_kwargs.get("num_samples")
        qnode = qml.QNode(circuit_for_spsr, dev, interface="jax", diff_method=None)
        grad_fn = spsr_evaluation(qnode, num_samples)

    return grad_fn


def evaluate_on_grid(fun, a_grid, b_grid, *other_args, sampled=False, **kwargs):
    """Evaluate a function on a grid of values for two parameters, ``a`` and ``b``.
    Optionally split the evaluation into mean and standard deviation.

    Args:
        fun (callable): function to evaluate
        a_grid (array): values of ``a`` to evaluate ``fun`` on.
        b_grid (array): values of ``b`` to evaluate ``fun`` on.
        other_args (tuple): additional arguments to be passed to ``fun``.
        sampled (bool): whether or not the function returns an array of results, of which
            the mean and standard deviation are returned if ``True``.
        kwargs (dict): additional keyword arguments to be passed to ``fun``.

    Returns:
        array or tuple[array]: The evaluations of the function ``fun`` on the grid
        defined by ``a_grid`` and ``b_grid``. If ``sampled=True``, a two-entry ``tuple`` of
        arrays is returned, with the mean in the first and the standard deviation in 
        the second entry.
    """
    shape = (len(a_grid), len(b_grid))
    if sampled:
        result_mean = np.zeros(shape)
        result_std = np.zeros(shape)
        for tuples in tqdm(product(enumerate(a_grid), enumerate(b_grid)), total=np.prod(shape)):
            ids, args = zip(*tuples)
            samples = fun(*args, *other_args, **kwargs)
            result_mean[ids] = jnp.mean(samples)
            result_std[ids] = jnp.std(samples)
        return result_mean, result_std
    else:
        result = np.zeros(shape)
        for tuples in product(enumerate(a_grid), enumerate(b_grid)):
            ids, args = zip(*tuples)
            result[ids] = fun(*args, *other_args, **kwargs)
        return result
