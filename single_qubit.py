from itertools import product
import pennylane as qml
import numpy as np
from pennylane.ops.qubit.special_unitary import pauli_basis_strings, pauli_basis_matrices
from pennylane.operation import Operation
import jax
jax.config.update("jax_enable_x64", True)
jnp = jax.numpy

def get_random_observable(N: int):
    basis = pauli_basis_matrices(N)
    c = np.random.randn(4 ** N - 1)
    return qml.math.tensordot(c, basis, axes=1)

class MyExp(Operation):

    num_params = 1
    num_wires = 1

    def __init__(self, t, wires, generator=None, do_queue=True, id=None):
        self._generator = generator
        self.num_wires = len(wires)
        super().__init__(t, wires=wires, do_queue=do_queue, id=id)
        self.hyperparameters["generator"] = generator

    def generator(self):
        """
        MyExp(t) = exp(t\Omega) = exp(i t (-i \Omega))
        """
        return -1j * self._generator

    @property
    def parameter_frequencies(self):
        eigvals = qml.math.linalg.eigvalsh(qml.math.to_numpy(qml.math.detach(self.generator())))
        fs = (qml.gradients.eigvals_to_frequencies(tuple(eigvals)),)
        return fs


    def adjoint(self):
        return MyExp(-self.data[0], wires=self.wires, generator=self._generator)

    @staticmethod
    def compute_matrix(t, generator):
        return qml.math.expm(t * generator)


def circuit(a, b, observable):
    """Quantum circuit with a single-qubit SpecialUnitary and an expectation value
    measurement. The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate.
    
    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        observable (qml.Observable): Observable to measure the expectation value of

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.])
    qml.SpecialUnitary(theta, [0])
    return qml.expval(observable)

def circuit_with_opg(a, b, t, observable):
    """Quantum circuit with a single-qubit SpecialUnitary, as well as a one-parameter group
    corresponding to the first parameter of said unitary, and an expectation value
    measurement. The circuit takes the parameters for the PauliX and PauliY components of
    the generator of the gate.
    
    Args:
        a (float): Parameter for PauliX component of the gate generator
        b (float): Parameter for PauliY component of the gate generator
        observable (qml.Observable): Observable to measure the expectation value of
        t (float): Parameter for the one-parameter group inserted before the SpecialUnitary gate.
            The one-parameter group is hard-coded to be generated by the effective generator
            corresponding to the first parameter of the SpecialUnitary gate.

    Returns:
        qml.measurements.ExpectationMP: Measurement process to obtain the expectation value.
    """
    theta = jnp.array([a, b, 0.])
    # Obtain the effective generator for the first parameter of the SpecialUnitary. For this,
    # we stop the queuing of PennyLane while creating the operation, and apply it manually later on
    with qml.queuing.QueuingManager.stop_recording():
        op = qml.SpecialUnitary(theta, [0])
    Omega = op.get_one_parameter_generators("jax")[0]

    MyExp(t, [0], generator=Omega)
    qml.apply(op)
    return qml.expval(observable)

def finite_diff_first(fun, dx=5e-5, argnums=0):
    """Compute the second-order finite difference approximation of the first order derivative."""
    if isinstance(argnums, int):
        argnums = [argnums]

    def wrapped(*args, **kwargs):
        grad = []
        for i in argnums:
            new_args = args[:i] + (args[i]+dx/2,) + args[i+1:]
            fun_plus = fun(*new_args, **kwargs)
            new_args = args[:i] + (args[i]-dx/2,) + args[i+1:]
            fun_minus = fun(*new_args, **kwargs)
            grad.append((fun_plus - fun_minus) / dx)
        return jnp.array(grad)

    return wrapped

def evaluate_on_grid(fun, a_grid, b_grid, *other_args, sampled=False, **kwargs):
    shape = (len(a_grid), len(b_grid))
    if sampled:
        result_mean = np.zeros(shape)
        result_std = np.zeros(shape)
        for tuples in product(enumerate(a_grid), enumerate(b_grid)):
            ids, args = zip(*tuples)
            samples = fun(*args, *other_args, **kwargs)
            result_mean[ids] = jnp.mean(samples)
            result_std[ids] = jnp.std(samples)
        return result_mean, result_std
    else:
        result = np.zeros(shape)
        for tuples in product(enumerate(a_grid), enumerate(b_grid)):
            ids, args = zip(*tuples)
            result[ids] = fun(*args, *other_args, **kwargs)
        return result



